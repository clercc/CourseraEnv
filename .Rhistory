install.packages(c("car", "cluster", "codetools", "foreign", "lattice", "lmtest", "Matrix", "mgcv", "nlme", "plm", "quantreg", "Rcpp", "RcppEigen", "SparseM", "survival", "tseries", "urca", "zoo"))
install.packages(c("slidify","ggplt2","devtools"))
install.packages(ggplot2")
install.packages("ggplot2")
install.packages("kernsmooth")
yes
install.packages(KernSmooth)
install.packages('KernSmooth')
library(KernSmooth)
library(swirl)
install.packages("swirl")
library(swirl)
library(swirl)
library(swirl)
swirl()
sapply(flags, unique)
vapply(flags, unique, numeric(1))
ok()
class(flags)
sapply(flags, class)
vapply(flags, class, character(1))
?tapply
table(flags$landmass)
table(flags$animate)
tapply(flags$animate, flags$landmass, mean)
View(viewinfo)
View(flags)
tapply(flags$population, flags$red, summary)
tapply(flags$population, flags$landmass, summary)
rm(list=ls())
x = 3
x = c(1,2,3)
mean() x
y <- NULL
y <- 38
mean(x) y
rm(list=ls())
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setsolve <- function(solve) m <<- solve
getsolve <- function() m
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
m <- x$getsolve()
if(!is.null(m)){
message("getting inverted maxtrix")
return(m)
}
data <- x$get()
m <- solve(data,...)
x$setsolve(m)
m
## Return a matrix that is the inverse of 'x'
}
b <- [1:2,3:4]
b <- c[1:2,3:4]
b <- as.matrix()[1:2,3:4]
b <- as.matrix([1:2,3:4])
b <- as.matrix(1:2,3:4)
b
b <- as.matrix(2:2,4:$)
b <- as.matrix(2:2,4:4)
b
b <- as.matrix(2:2)
b
b <- as.matrix(c(1,2,3,4))
b
b <- as.matrix(c(1,2,3,4),2:2)
b
b <- as.matrix(c([1,2],[3,4]))
b <- as.matrix(c(1,3),c(2,4))
b
?as.matrix
d <- c(1,2,3,4)
b <- as.matrix(d,2,2)
b
b <- as.matrix(d,nrow = 2, ncol = 2)
b
b <- as.matrix(,nrow = 2, ncol = 2)
b <- as.matrix(a ,nrow = 2, ncol = 2)
a <- c(1,3)
b <- c(2,4)
cbind(a,b)
d <- cbind(a,b)
class(d)
makeCacheMatrix(d)
cacheSolve(d)
akeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
cachemean <- function(x, ...) {
m <- x$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- mean(data, ...)
x$setmean(m)
m
}
rm(akeVector())
rm(akeVector
)
rm(cachemean)
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
cachemean <- function(x, ...) {
m <- x$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- mean(data, ...)
x$setmean(m)
m
}
t <- c(1,2,3,4,5)
cachemean(t)
solve(d)
cachemean(5)
x <- 1
h <- function() {
y <- 2
i <- function() {
z <- 3
c(x, y, z)
}
i()
}
h()
rm(x, h)
j <- function(x) {
y <- 2
function() {
c(x, y)
}
}
k <- j(1)
k()
rm(j, k)
l <- function(x) x + 1
m <- function() {
l <- function(x) x * 2
l(10)
}
m()
l(10)
m(20)
rm(l, m)
rm(a, b, t, d)
n <- function(x) x / 2
o <- function() {
n <- 10
n(n)
}
n(6)
o()
n(o)
rm(n,o)
?<<-
??<<-
??"<<-"
?"<<-"
?assignOps
a <- makeCacheMatrix()
a
a$set(matrix(1:4,2,2))
a
a$get()
cachesolve(a)
cacheSolve(a)
a$set(matrix(1:25,5,5))
cacheSolve(a)
a$set(matrix(1:16,4,4))
cacheSolve(a)
a$set(matrix(1:9,3,3))
cacheSolve(a)
a$set(matrix(2:10,3,3))
cacheSolve(a)
a$set(matrix(4:7,2,2))
cacheSolve(a)
a$set(matrix(c(1,3,5,7),2,2))
cacheSolve(a)
b <- matrix(c(seq(2:20, by = 2),3,3))
b <- matrix(c(seq(2:20, by = 2)),3,3)
a <- diag(5,5)
m <- makeCacheMatrix(a)
cacheSolve(m)
r = rnorm(100000)
m1 = matrix(r, nrow = 1000, ncol= 1000)
m = makeCacheMatrix(m1)
cacheSolve(m)
library(iris)
install.packages(iris)
library(datasets)
data(iris)
tapply(iris$Sepal.Length,iris$Species,mean)
set.seed(1)
rpois(5, 2)
rpois
system.time
setwd(/github)
setwd("~/Github/datasciencecoursera")
outcome <- read.csv("outcome-of-care-measures.csv", colClasses = 'character')
head(outcome)
ncol(outcome)
nrow(outcome)
names(outcome)
outcome[,11] - as.numeric(outcome[,11])
hist(outcome[,11],bins = 10)
hist(outcome[,11])
outcome[, 11] <- as.numeric(outcome[, 11])
hist(outcome[, 11])
hist(outcome[, 11], bins = 50)
hist(outcome[, 11], bin = 50)
hist(outcome[, 11], bin = 15)
hist
?hist
hist(outcome[, 11], breaks = 15)
hist(outcome[, 11], breaks = 50)
?lapply
data <- read.csv("C:/users/clercc/documents/github/datasciencecoursera/outcome-of-care-measures.csv", colClasses = "character")
data <- read.csv("C:/users/clercc/my documents/github/datasciencecoursera/outcome-of-care-measures.csv", colClasses = "character")
data <- read.csv("C:/users/cclerc/documents/github/datasciencecoursera/outcome-of-care-measures.csv", colClasses = "character")
statelist <- data$state
statelist
data
names(data)
statelist <- data[,7]
statelist
statelist <- invisible(sapply(data[,7],unique))
statelist
statelist <- data[,7]
outcomelist <- names(data[,c(11,17,23)])
outcomelist
outcomelist <- c("heart attack", "heart failure", "pneumonia")
outcomelist
best <- function(state, outcome) {
data <- read.csv("C:/users/cclerc/documents/github/datasciencecoursera/outcome-of-care-measures.csv", colClasses = "character")
statelist <- data[,7]
outcomelist <- c("heart attack", "heart failure", "pneumonia")
if (state %in% statelist & outcome %in% outcomelist) {
print(state, outcome)
}
}
best("TX","heart attack")
"TX" %in% statelist
state <- "TX"
print(state)
best("TX","heart attack")
"heart attack" %in% outcomelist
"TX" %in% statelist & "heart attack" %in% outcomelist
best <- function(state, outcome) {
data <- read.csv("C:/users/cclerc/documents/github/datasciencecoursera/outcome-of-care-measures.csv", colClasses = "character")
statelist <- data[,7]
outcomelist <- c("heart attack", "heart failure", "pneumonia")
if (state %in% statelist & outcome %in% outcomelist) {
print(state, outcome)
}
else {
print("please check your input")
}
}
best("TX","heart attack")
best <- function(state, outcome) {
data <- read.csv("C:/users/cclerc/documents/github/datasciencecoursera/outcome-of-care-measures.csv", colClasses = "character")
statelist <- data[,7]
outcomelist <- c("heart attack", "heart failure", "pneumonia")
if (state %in% statelist & outcome %in% outcomelist) {
print("state", "outcome")
}
else {
print("please check your input")
}
}
best("TX","heart attack")
best <- function(state, outcome) {
data <- read.csv("C:/users/cclerc/documents/github/datasciencecoursera/outcome-of-care-measures.csv", colClasses = "character")
statelist <- data[,7]
outcomelist <- c("heart attack", "heart failure", "pneumonia")
if (state %in% statelist & outcome %in% outcomelist) {
return(state, outcome)
}
else {
print("please check your input")
}
}
best("TX","heart attack")
best <- function(state, outcome) {
data <- read.csv("C:/users/cclerc/documents/github/datasciencecoursera/outcome-of-care-measures.csv", colClasses = "character")
statelist <- data[,7]
outcomelist <- c("heart attack", "heart failure", "pneumonia")
if (state %in% statelist & outcome %in% outcomelist) {
return(state)
return(outcome)
}
else {
print("please check your input")
}
}
best("TX","heart attack")
best <- function(state, outcome) {
data <- read.csv("C:/users/cclerc/documents/github/datasciencecoursera/outcome-of-care-measures.csv", colClasses = "character")
statelist <- data[,7]
outcomelist <- c("heart attack", "heart failure", "pneumonia")
if (state %in% statelist & outcome %in% outcomelist) {
#return(state)
return(outcome)
}
else {
print("please check your input")
}
}
best("TX","heart attack")
source('~/Github/datasciencecoursera/best.R', echo=TRUE)
best <- function(state, outcome) {
data <- read.csv("C:/users/cclerc/documents/github/datasciencecoursera/outcome-of-care-measures.csv", colClasses = "character")
statelist <- data[,7]
outcomelist <- c("heart attack", "heart failure", "pneumonia")
if (state %in% statelist & outcome %in% outcomelist) {
return(state)
#return(outcome)
}
else {
print("please check your input")
}
}
best("WZ","heart attack")
best("WA","heat attack")
best("WA","heart attack")
